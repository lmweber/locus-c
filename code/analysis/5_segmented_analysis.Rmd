---
title: "LC analyses: segmented analyses"
author: "Lukas Weber"
date: "19 Nov 2020"
output:
  html_document:
    toc: true
    number_sections: true
    toc_depth: 2
    toc_float:
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Introduction

Analyses for LC project: segmented analyses.

Segment out regions with or without neurons, and perform analyses within each region.


## Data

In this file, we are using the combined NextSeq and MiSeq reads for the LC samples (LC_1 and LC_2).


# Analysis

## Load data

Load data from Space Ranger outputs into R.

Notes about Space Ranger outputs:

- "raw" feature-barcode matrix contains all spots
- "filtered" feature-barcode matrix contains only spots identified as being under tissue
- more details: https://support.10xgenomics.com/spatial-gene-expression/software/pipelines/latest/output/matrices

Here we use the "filtered" feature-barcode matrix to create a `SingleCellExperiment`.

In the future, we will use `SpatialExperiment` instead (once the class structure is finalized): https://bioconductor.org/packages/SpatialExperiment

```{r, message=FALSE}
library(SingleCellExperiment)
library(Matrix)
library(rjson)
```

```{r}
sample_names <- c("LC_1", "LC_2")
sce_list <- vector("list", length = length(sample_names))
names(sce_list) <- sample_names

for (i in seq_along(sample_names)) {
  
  # ---------
  # load data
  # ---------
  
  # select sample
  sample_name <- sample_names[i]
  
  # path to Space Ranger output files
  if (Sys.info()["sysname"] == "Linux") {
    # files on JHPCE cluster
    dir_outputs <- "/dcl02/lieber/ajaffe/SpatialTranscriptomics/LIBD/locus-c/outputs/NextSeqMiSeq"
  } else if (Sys.info()["sysname"] == "Darwin") {
    # copy of files on Mac laptop
    dir_outputs <- "~/data/locus-c/outputs/NextSeqMiSeq"
  }
  
  # note: using "filtered" barcodes list containing only spots over tissue
  dir_matrix <- file.path(dir_outputs, sample_name, "outs", "filtered_feature_bc_matrix")
  
  # barcodes
  file_barcodes <- file.path(dir_matrix, "barcodes.tsv.gz")
  df_barcodes <- read.csv(file_barcodes, sep = "\t", header = FALSE, 
                          col.names = c("barcode_id"))
  # features
  file_features <- file.path(dir_matrix, "features.tsv.gz")
  df_features <- read.csv(file_features, sep = "\t", header = FALSE, 
                          col.names = c("gene_id", "gene_name", "feature_type"))
  # counts
  file_counts <- file.path(dir_matrix, "matrix.mtx.gz")
  counts <- readMM(file = file_counts)
  
  # spatial coordinates
  dir_spatial <- file.path(dir_outputs, sample_name, "outs", "spatial")
  file_tisspos <- file.path(dir_spatial, "tissue_positions_list.csv")
  df_tisspos <- read.csv(file_tisspos, header = FALSE, 
                         col.names=c("barcode_id", "in_tissue", "array_row", "array_col", 
                                     "pxl_col_in_fullres", "pxl_row_in_fullres"))
  
  # check dimensions
  dim(df_barcodes)
  dim(df_features)
  dim(counts)
  # note df_tisspos contains all spots (not filtered) - need to match later
  dim(df_tisspos)
  
  # image paths
  imageFilePath <- file.path(dir_spatial, c("tissue_hires_image.png", "tissue_lores_image.png"))
  
  # spatial scale factors
  file_scale <- file.path(dir_spatial, "scalefactors_json.json")
  scalefactors <- fromJSON(file = file_scale)
  
  
  # ---------------------------
  # create SingleCellExperiment
  # ---------------------------
  
  # note: check and/or re-order rows to make sure barcode IDs match in df_barcodes and df_tisspos
  dim(df_barcodes)
  dim(df_tisspos)
  ord <- match(df_barcodes$barcode_id, df_tisspos$barcode_id)
  df_tisspos_ord <- df_tisspos[ord, ]
  dim(df_tisspos_ord)
  stopifnot(nrow(df_barcodes) == nrow(df_tisspos_ord))
  stopifnot(all(df_barcodes$barcode_id == df_tisspos_ord$barcode_id))
  
  head(df_barcodes)
  head(df_tisspos_ord)
  
  col_data <- cbind(df_barcodes, df_tisspos_ord[, -1])
  head(col_data)
  
  sce <- SingleCellExperiment(
    rowData = df_features, 
    colData = col_data, 
    assays = c(counts = counts), 
    metadata = list(scalefactors = scalefactors)
  )
  
  sce
  
  # store object
  sce_list[[i]] <- sce
}

sce_list
```


## Calculate scater QC metrics

```{r, message=FALSE}
library(here)
library(scater)
library(ggplot2)
```

```{r, message=FALSE}
for (i in seq_along(sample_names)) {
  
  # select sample
  sce <- sce_list[[i]]
  
  # identify mitochondrial genes
  is_mito <- grepl("(^MT-)|(^mt-)", rowData(sce)$gene_name)
  table(is_mito)
  rowData(sce)$gene_name[is_mito]
  
  # calculate QC metrics using scater package
  sce <- addPerCellQC(sce, subsets = list(mito = is_mito))
  
  colData(sce)
  
  # store
  sce_list[[i]] <- sce
}
```


## Plot UMI counts

Use UMI counts as criterion for segmentation (see also plots in previous RMarkdown file `2_features_per_spot_LC.Rmd`).

```{r, message=FALSE, fig.width=4.75, fig.height=3.5}
# number of UMI counts per spot in different regions of each sample

thresh_counts_high <- c(4000, 2000)

for (i in seq_along(sample_names)) {
  
  # select sample
  sce <- sce_list[[i]]
  
  # identify spots with high/low counts
  colData(sce)$is_high_counts <- colData(sce)$sum > thresh_counts_high[i]
  # store object
  sce_list[[i]] <- sce
  
  
  # plot UMI counts per spot
  
  p <- ggplot(as.data.frame(colData(sce)), 
              aes(x = pxl_row_in_fullres, y = pxl_col_in_fullres, color = sum)) + 
    geom_point(size = 0.5) + 
    coord_fixed() + 
    scale_y_reverse() + 
    scale_color_gradient(low = "gray95", high = "navy") + 
    ggtitle(paste0("UMI counts per spot: ", sample_names[i])) + 
    theme_bw() + 
    theme(panel.grid = element_blank(), 
          axis.title = element_blank(), 
          axis.text = element_blank(), 
          axis.ticks = element_blank())
  
  print(p)
  
  
  # plot spots with high UMI counts
  
  p <- ggplot(as.data.frame(colData(sce)), 
              aes(x = pxl_row_in_fullres, y = pxl_col_in_fullres, color = is_high_counts)) + 
    geom_point(size = 0.5) + 
    coord_fixed() + 
    scale_y_reverse() + 
    scale_color_manual(values = c("gray95", "red")) + 
    ggtitle(paste0("Spots with UMI counts > ", thresh_counts_high[i], ": ", sample_names[i])) + 
    theme_bw() + 
    theme(panel.grid = element_blank(), 
          axis.title = element_blank(), 
          axis.text = element_blank(), 
          axis.ticks = element_blank())
  
  print(p)
}
```


## Segment regions

Segment spatially contiguous regions of high and low UMI counts based on previous plots.

```{r, message=FALSE, fig.width=4.75, fig.height=3.5}
# segment regions

dir_plot <- here("plots", "segmented_analysis")
if (!dir.exists(dir_plot)) dir.create(dir_plot, recursive = TRUE)

y_region_high <- c(24000, 23000)

for (i in seq_along(sample_names)) {
  
  # select sample
  sce <- sce_list[[i]]
  
  # segment region of high UMI counts
  colData(sce)$is_region_high <- colData(sce)$pxl_col_in_fullres > y_region_high[i]
  # store object
  sce_list[[i]] <- sce
  
  
  # plot region
  
  p <- ggplot(as.data.frame(colData(sce)), 
              aes(x = pxl_row_in_fullres, y = pxl_col_in_fullres, color = is_region_high)) + 
    geom_point(size = 0.5) + 
    coord_fixed() + 
    scale_y_reverse() + 
    scale_color_manual(values = c("gray95", "red")) + 
    ggtitle(paste0("Segmented region (high UMI counts): ", sample_names[i])) + 
    theme_bw() + 
    theme(panel.grid = element_blank(), 
          axis.title = element_blank(), 
          axis.text = element_blank(), 
          axis.ticks = element_blank())
  
  print(p)
  
  fn <- file.path(dir_plot, paste0("xyplot_segmented_region_", sample_names[i], ".png"))
  ggsave(fn, width = 4.75, height = 3.5)
}
```



## Segmented analysis pipeline

### Segment region

(1) Segment region using high and low UMI counts (regardless of spatial position)

```{r}
# one sample for now
sce <- sce_list[[1]]

# segment region
dim(sce)
sce <- sce[, colData(sce)$is_high_counts]
dim(sce)
```


### Quality control

Check additional QC metrics.


### Normalization and transformation

```{r, message=FALSE, fig.height=4}
library(scran)

# quick clustering for pool-based size factors
set.seed(123)
qclus <- quickCluster(sce)
table(qclus)

# calculate size factors and store in object
sce <- computeSumFactors(sce, cluster = qclus)

summary(sizeFactors(sce))
hist(log10(sizeFactors(sce)), xlab = "log10 (size factors)", main = "Size factors")

# calculate logcounts (log-transformed normalized counts) and store in object
sce <- logNormCounts(sce)

assayNames(sce)
```


### Feature selection

```{r}
# remove mitochondrial genes
is_mito <- grepl("(^MT-)|(^mt-)", rowData(sce)$gene_name)
table(is_mito)
rowData(sce)$gene_name[is_mito]
  
dim(sce)
sce <- sce[!is_mito, ]
dim(sce)

# remove low-count genes
is_low <- rowSums(counts(sce)) < 10
table(is_low)

dim(sce)
sce <- sce[!is_low, ]
dim(sce)
```

```{r, message=FALSE, fig.height=5}
# fit mean-variance relationship
dec <- modelGeneVar(sce)

# visualize mean-variance relationship
fit <- metadata(dec)
plot(fit$mean, fit$var, 
     xlab = "mean of log-expression", ylab = "variance of log-expression")
curve(fit$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# select top HVGs
top_hvgs <- getTopHVGs(dec, prop = 0.1)
length(top_hvgs)
```

```{r}
# identify outlier genes
# rev(sort(fit$mean))[1:3]
# outlier_ids <- names(rev(sort(fit$mean))[1:3])

# rowData(spe)[outlier_ids, ]
```


### Dimensionality reduction

```{r}
# calculate PCA
set.seed(123)
sce <- runPCA(sce, subset_row = top_hvgs)

reducedDimNames(sce)
dim(reducedDim(sce, "PCA"))
```

```{r}
# calculate UMAP on top 50 PCs
set.seed(123)
sce <- runUMAP(sce, dimred = "PCA")

reducedDimNames(sce)
dim(reducedDim(sce, "UMAP"))

# update column names for plotting
colnames(reducedDim(sce, "UMAP")) <- paste0("UMAP", 1:2)
```


### Clustering

```{r}
# graph-based clustering
set.seed(123)
k <- 20
g <- buildSNNGraph(sce, k = k, use.dimred = "PCA")
g_walk <- igraph::cluster_walktrap(g)
clus <- g_walk$membership
table(clus)

# store cluster labels in object (column "label")
colLabels(sce) <- factor(clus)
```


```{r, fig.height=4.5, fig.width=5.5}
# define custom color palette
colors <- unname(palette.colors(palette = "Okabe-Ito"))

# plot clusters in x-y coordinates
p <- ggplot(as.data.frame(colData(sce)), 
            aes(x = pxl_row_in_fullres, y = pxl_col_in_fullres, color = label)) + 
  geom_point(size = 0.5) + 
  scale_color_manual(values = colors) + 
  coord_fixed() + 
  scale_y_reverse() + 
  ggtitle("Spatial coordinates (spots)") + 
  theme_bw() + 
  theme(panel.grid = element_blank(), 
        axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks = element_blank())
p

fn <- file.path(dir_plot, paste0("xyplot_segmented_region_clustering_1_", sample_names[i], ".png"))
ggsave(fn, width = 4.75, height = 3.5)
```



## Segmented analysis pipeline (2)

### Segment region

(2) Segment region using spatially contiguous region of high UMI counts

```{r}
# one sample for now
sce <- sce_list[[1]]

# segment region
dim(sce)
sce <- sce[, colData(sce)$is_region_high]
dim(sce)
```


### Quality control

Check additional QC metrics.


### Normalization and transformation

```{r, message=FALSE, fig.height=4}
library(scran)

# quick clustering for pool-based size factors
set.seed(123)
qclus <- quickCluster(sce)
table(qclus)

# calculate size factors and store in object
sce <- computeSumFactors(sce, cluster = qclus)

summary(sizeFactors(sce))
hist(log10(sizeFactors(sce)), xlab = "log10 (size factors)", main = "Size factors")

# calculate logcounts (log-transformed normalized counts) and store in object
sce <- logNormCounts(sce)

assayNames(sce)
```


### Feature selection

```{r}
# remove mitochondrial genes
is_mito <- grepl("(^MT-)|(^mt-)", rowData(sce)$gene_name)
table(is_mito)
rowData(sce)$gene_name[is_mito]
  
dim(sce)
sce <- sce[!is_mito, ]
dim(sce)

# remove low-count genes
is_low <- rowSums(counts(sce)) < 10
table(is_low)

dim(sce)
sce <- sce[!is_low, ]
dim(sce)
```

```{r, message=FALSE, fig.height=5}
# fit mean-variance relationship
dec <- modelGeneVar(sce)

# visualize mean-variance relationship
fit <- metadata(dec)
plot(fit$mean, fit$var, 
     xlab = "mean of log-expression", ylab = "variance of log-expression")
curve(fit$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# select top HVGs
top_hvgs <- getTopHVGs(dec, prop = 0.1)
length(top_hvgs)
```

```{r}
# identify outlier genes
# rev(sort(fit$mean))[1:3]
# outlier_ids <- names(rev(sort(fit$mean))[1:3])

# rowData(spe)[outlier_ids, ]
```


### Dimensionality reduction

```{r}
# calculate PCA
set.seed(123)
sce <- runPCA(sce, subset_row = top_hvgs)

reducedDimNames(sce)
dim(reducedDim(sce, "PCA"))
```

```{r}
# calculate UMAP on top 50 PCs
set.seed(123)
sce <- runUMAP(sce, dimred = "PCA")

reducedDimNames(sce)
dim(reducedDim(sce, "UMAP"))

# update column names for plotting
colnames(reducedDim(sce, "UMAP")) <- paste0("UMAP", 1:2)
```


### Clustering

```{r}
# graph-based clustering
set.seed(123)
k <- 20
g <- buildSNNGraph(sce, k = k, use.dimred = "PCA")
g_walk <- igraph::cluster_walktrap(g)
clus <- g_walk$membership
table(clus)

# store cluster labels in object (column "label")
colLabels(sce) <- factor(clus)
```


```{r, fig.height=4.5, fig.width=5.5}
# define custom color palette
colors <- unname(palette.colors(palette = "Okabe-Ito"))

# plot clusters in x-y coordinates
p <- ggplot(as.data.frame(colData(sce)), 
            aes(x = pxl_row_in_fullres, y = pxl_col_in_fullres, color = label)) + 
  geom_point(size = 0.5) + 
  scale_color_manual(values = colors) + 
  coord_fixed() + 
  scale_y_reverse() + 
  ggtitle("Spatial coordinates (spots)") + 
  theme_bw() + 
  theme(panel.grid = element_blank(), 
        axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks = element_blank())
p

fn <- file.path(dir_plot, paste0("xyplot_segmented_region_clustering_2_", sample_names[i], ".png"))
ggsave(fn, width = 4.75, height = 3.5)
```




## Segmented analysis pipeline (3)

### Segment region

(3) Segment region using spatially contiguous region of high UMI counts

```{r}
# one sample for now
sce <- sce_list[[2]]

# segment region
dim(sce)
sce <- sce[, colData(sce)$is_region_high]
dim(sce)
```


### Quality control

Check additional QC metrics.


### Normalization and transformation

```{r, message=FALSE, fig.height=4}
library(scran)

# quick clustering for pool-based size factors
set.seed(123)
qclus <- quickCluster(sce)
table(qclus)

# calculate size factors and store in object
sce <- computeSumFactors(sce, cluster = qclus)

summary(sizeFactors(sce))
hist(log10(sizeFactors(sce)), xlab = "log10 (size factors)", main = "Size factors")

# calculate logcounts (log-transformed normalized counts) and store in object
sce <- logNormCounts(sce)

assayNames(sce)
```


### Feature selection

```{r}
# remove mitochondrial genes
is_mito <- grepl("(^MT-)|(^mt-)", rowData(sce)$gene_name)
table(is_mito)
rowData(sce)$gene_name[is_mito]
  
dim(sce)
sce <- sce[!is_mito, ]
dim(sce)

# remove low-count genes
is_low <- rowSums(counts(sce)) < 10
table(is_low)

dim(sce)
sce <- sce[!is_low, ]
dim(sce)
```

```{r, message=FALSE, fig.height=5}
# fit mean-variance relationship
dec <- modelGeneVar(sce)

# visualize mean-variance relationship
fit <- metadata(dec)
plot(fit$mean, fit$var, 
     xlab = "mean of log-expression", ylab = "variance of log-expression")
curve(fit$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# select top HVGs
top_hvgs <- getTopHVGs(dec, prop = 0.1)
length(top_hvgs)
```

```{r}
# identify outlier genes
# rev(sort(fit$mean))[1:3]
# outlier_ids <- names(rev(sort(fit$mean))[1:3])

# rowData(spe)[outlier_ids, ]
```


### Dimensionality reduction

```{r}
# calculate PCA
set.seed(123)
sce <- runPCA(sce, subset_row = top_hvgs)

reducedDimNames(sce)
dim(reducedDim(sce, "PCA"))
```

```{r}
# calculate UMAP on top 50 PCs
set.seed(123)
sce <- runUMAP(sce, dimred = "PCA")

reducedDimNames(sce)
dim(reducedDim(sce, "UMAP"))

# update column names for plotting
colnames(reducedDim(sce, "UMAP")) <- paste0("UMAP", 1:2)
```


### Clustering

```{r}
# graph-based clustering
set.seed(123)
k <- 20
g <- buildSNNGraph(sce, k = k, use.dimred = "PCA")
g_walk <- igraph::cluster_walktrap(g)
clus <- g_walk$membership
table(clus)

# store cluster labels in object (column "label")
colLabels(sce) <- factor(clus)
```


```{r, fig.height=4.5, fig.width=5.5}
# define custom color palette
colors <- unname(palette.colors(palette = "Okabe-Ito"))

# plot clusters in x-y coordinates
p <- ggplot(as.data.frame(colData(sce)), 
            aes(x = pxl_row_in_fullres, y = pxl_col_in_fullres, color = label)) + 
  geom_point(size = 0.5) + 
  scale_color_manual(values = colors) + 
  coord_fixed() + 
  scale_y_reverse() + 
  ggtitle("Spatial coordinates (spots)") + 
  theme_bw() + 
  theme(panel.grid = element_blank(), 
        axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks = element_blank())
p

fn <- file.path(dir_plot, paste0("xyplot_segmented_region_clustering_3_", sample_names[i], ".png"))
ggsave(fn, width = 4.75, height = 3.5)
```



# Session info

```{r, message=FALSE}
sessionInfo()
```

